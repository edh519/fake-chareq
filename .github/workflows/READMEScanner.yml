name: Org README Review Checker

on:
  schedule:
    - cron: '0 7 * * 1'
  workflow_dispatch:

jobs:
  check:
    runs-on: ubuntu-latest

    steps:
      - name: Check repos
        env:
          ORG: uoy-trials
          TOKEN: ${{ secrets.AUTH_GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.AUTH_GITHUB_TOKEN }}
          THRESHOLD_DAYS: 28
          RETIRE_THRESHOLD: 28
        run: |
          TODAY=$(date +%s)
          DUE_LIST=""
          RETIRE_LIST=""

          echo "Fetching repos for $ORG..."
          repos=$(gh api --paginate /orgs/$ORG/repos \
            -q '.[] | select(.archived == false and (.name | startswith("stats-") | not)) | .name')

          for repo in $repos; do
            echo "Checking $repo..."

            # Skip forks
            is_fork=$(gh api /repos/$ORG/$repo -q '.fork')
            if [ "$is_fork" = "true" ]; then
              echo "$repo is a fork â€” skipping"
              continue
            fi

            # Fetch README
            readme=$(gh api /repos/$ORG/$repo/readme -q '.content' | base64 --decode)

            if [[ "$readme" ]]; then
              # Extract fields safely
              status=$(echo "$readme" | grep "Repo-Status" | head -n1 | cut -d':' -f2- | sed 's/^ *//;s/ *$//' || echo "")
              contents=$(echo "$readme" | grep "Repo-Contents" | head -n1 | cut -d':' -f2- | sed 's/^ *//;s/ *$//' || echo "")
              service_name=$(echo "$readme" | grep "Repo-Service-Name" | head -n1 | cut -d':' -f2- | sed 's/^ *//;s/ *$//' || echo "")
              ownership=$(echo "$readme" | grep "Repo-Ownership-Rating" | head -n1 | cut -d':' -f2- | sed 's/^ *//;s/ *$//' || echo "")
              quality=$(echo "$readme" | grep "Repo-Quality-Rating" | head -n1 | cut -d':' -f2- | sed 's/^ *//;s/ *$//' || echo "")
              next_review=$(echo "$readme" | grep "Repo-Next-Review-Due" | head -n1 | cut -d':' -f2- | sed 's/^ *//;s/ *$//' || echo "")
              retirement=$(echo "$readme" | grep "Repo-Expected-Retirement-Date" | head -n1 | cut -d':' -f2- | sed 's/^ *//;s/ *$//' || echo "")

              # Review due
              if [ -n "$next_review" ]; then
                reviewEpoch=$(date -d "$next_review" +%s 2>/dev/null || echo 0)
                diffDays=$(( (reviewEpoch - TODAY) / 86400 ))
                if [ "$reviewEpoch" -gt 0 ] && [ "$diffDays" -le $THRESHOLD_DAYS ]; then
                  DUE_LIST="$DUE_LIST\n- $repo | Status: $status | Next Review: $next_review | Service: $service_name"
                fi
              fi

              # Retirement due
              if [ -n "$retirement" ]; then
                retireEpoch=$(date -d "$retirement" +%s 2>/dev/null || echo 0)
                retireDays=$(( (retireEpoch - TODAY) / 86400 ))
                if [ "$retireEpoch" -gt 0 ] && [ "$retireDays" -le $RETIRE_THRESHOLD ]; then
                  RETIRE_LIST="$RETIRE_LIST\n- $repo | Status: $status | Retirement: $retirement | Service: $service_name"
                fi
              fi

            fi

          done 

          # Output results
          echo -e "Reviews due soon:$DUE_LIST"
          echo -e "Repositories retiring soon:$RETIRE_LIST"

          echo "due_list<<EOF" >> $GITHUB_OUTPUT
          echo -e "$DUE_LIST" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "retire_list<<EOF" >> $GITHUB_OUTPUT
          echo -e "$RETIRE_LIST" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Initialize table header
          REVIEWS_TABLE="| Repo | Status | Next Review | Service | Days | Due Status |\n| --- | --- | --- | --- | --- | --- |"
          
          # Temporary array to hold rows with epoch for sorting
          rows=()
          
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            repo=$(echo "$line" | cut -d'|' -f1 | sed 's/- //;s/^ *//;s/ *$//')
            status=$(echo "$line" | cut -d'|' -f2 | sed 's/Status: //;s/^ *//;s/ *$//')
            next_review=$(echo "$line" | cut -d'|' -f3 | sed 's/Next Review: //;s/^ *//;s/ *$//')
            service=$(echo "$line" | cut -d'|' -f4 | sed 's/Service: //;s/^ *//;s/ *$//')
          
            # Calculate epoch
            reviewEpoch=$(date -d "$next_review" +%s 2>/dev/null || echo 0)
            diffDays=$(( (reviewEpoch - TODAY) / 86400 ))
          
            # Determine due status
            if [ "$diffDays" -lt 0 ]; then
              due_status="overdue"
              diffDays=$(( -diffDays ))  # show overdue in positive days
            else
              due_status="due soon"
            fi
          
            # Save row with epoch for sorting
            rows+=("$reviewEpoch|$repo|$status|$next_review|$service|$diffDays|$due_status")
          done <<< "$DUE_LIST"
          
          # Sort rows by epoch ascending
          IFS=$'\n' sorted_rows=($(sort -n <<<"${rows[*]}"))
          
          # Build table
          for row in "${sorted_rows[@]}"; do
            IFS='|' read -r _repo _repoName _status _date _service _days _dueStatus <<< "$row"
            REVIEWS_TABLE="$REVIEWS_TABLE\n| $_repoName | $_status | $_date | $_service | $_days | $_dueStatus |"
          done

          # Initialize table header
          RETIRE_TABLE="| Repo | Status | Retirement | Service | Days | Due Status |\n| --- | --- | --- | --- | --- | --- |"
          
          # Temporary array to hold rows with epoch for sorting
          retire_rows=()
          
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            repo=$(echo "$line" | cut -d'|' -f1 | sed 's/- //;s/^ *//;s/ *$//')
            status=$(echo "$line" | cut -d'|' -f2 | sed 's/Status: //;s/^ *//;s/ *$//')
            retirement=$(echo "$line" | cut -d'|' -f3 | sed 's/Retirement: //;s/^ *//;s/ *$//')
            service=$(echo "$line" | cut -d'|' -f4 | sed 's/Service: //;s/^ *//;s/ *$//')
          
            # Calculate epoch
            retireEpoch=$(date -d "$retirement" +%s 2>/dev/null || echo 0)
            diffDays=$(( (retireEpoch - TODAY) / 86400 ))
          
            # Determine due status
            if [ "$diffDays" -lt 0 ]; then
              due_status="overdue"
              diffDays=$(( -diffDays ))  # show overdue as positive
            else
              due_status="due soon"
            fi
          
            # Save row with epoch for sorting
            retire_rows+=("$retireEpoch|$repo|$status|$retirement|$service|$diffDays|$due_status")
          done <<< "$RETIRE_LIST"
          
          # Sort rows by epoch ascending
          IFS=$'\n' sorted_retire_rows=($(sort -n <<<"${retire_rows[*]}"))
          
          # Build table
          for row in "${sorted_retire_rows[@]}"; do
            IFS='|' read -r _repo _repoName _status _date _service _days _dueStatus <<< "$row"
            RETIRE_TABLE="$RETIRE_TABLE\n| $_repoName | $_status | $_date | $_service | $_days | $_dueStatus |"
          done

          echo -e "$REVIEWS_TABLE" | column -t -s '|'
          echo -e "$RETIRE_TABLE" | column -t -s '|'

