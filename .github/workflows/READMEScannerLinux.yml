name: README Scanner

on:
  schedule:
    - cron: '0 7 * * 1'
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  check:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Fetch repos
        id: repos
        uses: actions/github-script@v8
        env:
          ORG: uoy-trials
        with:
          github-token: ${{ secrets.AUTH_GITHUB_TOKEN }}
          script: |
            const org = process.env.ORG;
            const repos = await github.paginate(
              github.rest.repos.listForOrg,
              { org }
            );
            const filtered = repos
              .filter(r => !r.archived && !r.name.startsWith("stats-"))
              .map(r => r.name);
            
            return filtered;

      - name: Check repos metadata
        uses: actions/github-script@v8
        env:
          ORG: uoy-trials
          REPO_LIST: ${{ steps.repos.outputs.result }}
          THRESHOLD_DAYS: 30
        with:
          github-token: ${{ secrets.AUTH_GITHUB_TOKEN }}
          script: |
            const org = process.env.ORG;
            const repoNames = JSON.parse(process.env.REPO_LIST);
            const today = new Date();
            const thresholdDays = parseInt(process.env.THRESHOLD_DAYS);
            
            let reviewList = "";
            let retireList = "";

            for (const name of repoNames) {
              console.log(`Processing: ${name}`);
              
                const { data: readmeFile } = await github.rest.repos.getReadme({
                  owner: org,
                  repo: name,
                });
                
                const content = Buffer.from(readmeFile.content, 'base64').toString('utf-8');

                const getMeta = (key) => {
                  const regex = new RegExp(`${key}\\s*:\\s*(.*)`, 'i');
                  const match = content.match(regex);
                  return match ? match[1].trim() : null;
                };

                const status = getMeta("Repo-Status") || "Unknown";
                const serviceName = getMeta("Repo-Service-Name") || "Unknown";
                const nextReviewStr = getMeta("Repo-Next-Review-Due");
                const retirementStr = getMeta("Repo-Expected-Retirement-Date");

                const getDiffDays = (dateStr) => {
                  if (!dateStr || dateStr.toLowerCase() === 'tbc') return null;
                  const targetDate = new Date(dateStr);
                  if (isNaN(targetDate.getTime())) return null;
                  return Math.ceil((targetDate - today) / (1000 * 60 * 60 * 24));
                };

                const reviewDiff = getDiffDays(nextReviewStr);
                
                if (reviewDiff !== null && reviewDiff <= thresholdDays) {
                  reviewList += `\n- ${name} | Status: ${status} | Next Review: ${nextReviewStr} | Service: ${serviceName}`;
                }

                const retireDiff = getDiffDays(retirementStr);
                
                if (retireDiff !== null && retireDiff <= thresholdDays) {
                  retireList += `\n- ${name} | Status: ${status} | Retirement: ${retirementStr} | Service: ${serviceName}`;
                }
            }

            core.exportVariable('REVIEW_LIST', reviewList.trim());
            core.exportVariable('RETIRE_LIST', retireList.trim());

      - name: Build tables
        shell: bash
        run: |
            # Use UTC timestamp for consistency
            TODAY=$(date -u +%s)
  
            # Function to process lists into Markdown tables
            generate_table() {
              local input_list="$1"
              local table_header="$2"
              local date_label="$3" # "Next Review" or "Retirement"
              local rows=()
  
              # If the list is empty, return a default message
              if [ -z "$input_list" ]; then
                echo "No items found."
                return
              fi
  
              # Read the list line by line
              while IFS= read -r line; do
                [ -z "$line" ] && continue
                
                # Extract fields based on the pipe delimiter
                # Expected format: - repo | Status: X | Next Review: Y | Service: Z
                repo=$(echo "$line" | cut -d'|' -f1 | sed 's/- //;s/^ *//;s/ *$//')
                status=$(echo "$line" | cut -d'|' -f2 | sed 's/Status: //;s/^ *//;s/ *$//')
                target_date=$(echo "$line" | cut -d'|' -f3 | sed "s/$date_label: //;s/^ *//;s/ *$//")
                service=$(echo "$line" | cut -d'|' -f4 | sed 's/Service: //;s/^ *//;s/ *$//')
  
                # Convert date to epoch for sorting and math
                targetEpoch=$(date -d "$target_date" +%s 2>/dev/null || echo 0)
                
                if [ "$targetEpoch" -gt 0 ]; then
                  diffSeconds=$(( targetEpoch - TODAY ))
                  diffDays=$(( diffSeconds / 86400 ))
                  
                  due_status="due soon"
                  displayDays=$diffDays
                  if [ "$diffDays" -lt 0 ]; then
                    due_status="**overdue**"
                    displayDays=$(( -diffDays ))
                  fi
                  
                  # Store with epoch prefix for sorting
                  rows+=("$targetEpoch|$repo|$status|$target_date|$service|$displayDays|$due_status")
                fi
              done <<< "$input_list"
  
              # Output Header
              echo -e "$table_header"
              
              # Sort by epoch (first column) and format as table rows
              if [ ${#rows[@]} -eq 0 ]; then
                 echo "| N/A | N/A | N/A | N/A | N/A | N/A |"
              else
                 printf "%s\n" "${rows[@]}" | sort -n | while IFS='|' read -r _epoch _repo _status _date _service _days _dueStatus; do
                   echo "| $_repo | $_status | $_date | $_service | $_days | $_dueStatus |"
                 done
              fi
            }
  
            # 1. Generate Reviews Table
            REVIEW_HDR="| Repo | Status | Next Review | Service | Days | Due Status |\n| --- | --- | --- | --- | --- | --- |"
            REVIEWS_TABLE=$(generate_table "$REVIEW_LIST" "$REVIEW_HDR" "Next Review")
  
            echo "REVIEWS_TABLE<<EOF" >> $GITHUB_ENV
            echo -e "$REVIEWS_TABLE" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
  
            # 2. Generate Retirement Table
            RETIRE_HDR="| Repo | Status | Retirement | Service | Days | Due Status |\n| --- | --- | --- | --- | --- | --- |"
            RETIRE_TABLE=$(generate_table "$RETIRE_LIST" "$RETIRE_HDR" "Retirement")
  
            echo "RETIRE_TABLE<<EOF" >> $GITHUB_ENV
            echo -e "$RETIRE_TABLE" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          
      - name: Send email
        uses: dawidd6/action-send-mail@v5
        with:
          server_address: ${{ secrets.MAIL_SERVER }}
          server_port: ${{ secrets.MAIL_PORT }}
          username: ${{ secrets.MAIL_USERNAME }}
          subject: "GitHub README Scanner"
          to: ytu-techsupport-group@york.ac.uk
          from: "${{ github.repository }} <${{ secrets.MAIL_USERNAME }}>"
          reply_to: ytu-techsupport-group@york.ac.uk
          content_type: text/markdown
          body: |
            ## Repos with Reviews Due Soon
            ${{ env.REVIEWS_TABLE }}

            ## Repos Retiring Soon
            ${{ env.RETIRE_TABLE }}
